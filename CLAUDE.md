# Claude Code Guidelines for coppercli

This project is derived from OpenCNCPilot (`~/src/OpenCNCPilot/`). When confused about GRBL communication or probing logic, check that reference implementation.

G-code is typically generated by pcb2gcode. Custom tools are in `~/src/pcb2gcode-tools/`.

## Start of Conversation

Check for Dropbox conflicted copies and delete them:
```bash
find . -name "*conflicted*" -ls          # review first
find . -name "*conflicted*" -delete      # then delete
```

## Code Style

**Keep it simple.** If code gets complex (multiple flags, nested conditions, complex state tracking), stop and rethink. Keep files small.

**Clean as you go.** When you encounter violations, take time to fix them: pursue DRY aggressively, refactor into utility functions, extract constants.

**Always use braces** for control statements, even single-line bodies:
```csharp
if (condition)
{
    DoSomething();
}
```

**No magic values.** Every literal with semantic meaning must be a constant. This includes: timeouts, speeds/feeds, baud rates, status strings (`"Idle"`, `"Alarm"`), UI text, buffer sizes, retry counts, protocol values. If a constant doesn't exist, create it.

```csharp
// BAD
Thread.Sleep(500);
if (status == "Home") ...
if (status.StartsWith("Alarm")) ...

// GOOD
Thread.Sleep(ConnectionDelayMs);
if (status == StatusHome) ...
if (status.StartsWith(StatusAlarm)) ...
```

**DRY.** Before writing new code, check `coppercli/Helpers/` for existing status checks, wait functions, machine commands, display utilities, and menu helpers. Extract repeated patterns into helpers:

```csharp
// Extract repeated checks into helpers
if (!RequireConnection()) return;
```

**Menu definitions** should be structured data, not scattered strings:
```csharp
static readonly (string Label, char Mnemonic, Action Handler)[] MainMenuItems = {
    ("Connect/Disconnect", 'c', ConnectionMenu),
    ("Home ($H)", 'h', HomeMenu),
};
```

## Project Structure

- `coppercli/` - Main application (.NET 8)
- `coppercli.Core/` - Platform-independent core library (.NET 8)

**Important:** Core cannot reference coppercli (dependency flows one way). Shared constants used by Core go in `coppercli.Core/Util/Constants.cs`.

### Constants Location

- **`coppercli.Core/Util/Constants.cs`** - Shared constants used by Core (serial timeouts, buffer sizes, GRBL defaults)
- **`coppercli/CliConstants.cs`** - CLI-specific constants (UI text, display settings, menu timing)
- **`coppercli.Core/Util/GrblProtocol.cs`** - GRBL protocol constants (status strings, commands)

### Helper Organization

- **`StatusHelpers.cs`** - Status checks (`IsIdle`, `IsAlarm`), wait functions (`WaitForIdle`, `WaitForZHeight`)
- **`MachineCommands.cs`** - G-code patterns (`RaiseZRelative`, `RapidMoveAndWaitZ`, `EnsureMachineReady`)
- **`MenuHelpers.cs`** - Menu display, prompts, confirmation dialogs
- **`DisplayHelpers.cs`** - ANSI codes, terminal output, progress display
- **`InputHelpers.cs`** - Keyboard input, key matching

## Debugging

Log file location: `coppercli/bin/Debug/net8.0/coppercli.log`

## Git

**IMPORTANT:** NEVER run git commands (add, commit, push, etc.) unless the user EXPLICITLY asks. Do not volunteer git commands. Do not stage files automatically after editing. Do not commit. Do not push. Wait for explicit instructions.

## Building

**IMPORTANT:** Do not compile unless the user explicitly asks. This project is synced via Dropbox, and compiling while the user is also working can create conflicted copies of build artifacts.

### dotnet on macOS

On macOS, `dotnet` is often not in PATH. See `run.sh` for common locations.

### Running

Use the platform-agnostic run scripts which auto-detect dotnet location:

```bash
# macOS/Linux
./run.sh

# Windows (double-click or command line)
run.bat
```

### Manual build commands

```bash
dotnet build coppercli/coppercli.csproj
dotnet run --project coppercli/coppercli.csproj
dotnet build coppercli/coppercli.csproj -warnaserror  # treat warnings as errors
```

## Releases

### Creating a Release

Releases are automated via GitHub Actions. When you push a tag, GitHub builds for all platforms and creates a release:

```bash
git tag v0.1.2
git push origin v0.1.2
```

This automatically:
- Builds Windows x64 (portable exe)
- Builds Windows installer (via Inno Setup)
- Builds macOS ARM64 and x64
- Builds Linux x64
- Creates a GitHub Release with all artifacts

### Windows Installer

The Windows installer is built with [Inno Setup](https://jrsoftware.org/isinfo.php). Configuration is in `installer/coppercli.iss`.

To build locally on Windows:
```bash
installer\build-installer.bat
```

The icon (`installer/coppercli.ico`) was generated from a JPG using ImageMagick:
```bash
magick input.jpg -define icon:auto-resize=256,128,64,48,32,16 coppercli.ico
```

### Homebrew Tap

The Homebrew tap is a separate repo: `github.com/thomergil/homebrew-coppercli` (cloned at `~/src/homebrew-coppercli`).

After creating a GitHub release, update the formula. For example:
```bash
./scripts/update-homebrew-formula.sh v0.1.2
cd ~/src/homebrew-coppercli
git add Formula/coppercli.rb
git commit -m "Update to v0.1.2"
git push
```

### Version Number

The version must be updated in **two places** before creating a release:

1. `coppercli/CliConstants.cs` - `AppVersion` constant (with `v` prefix, e.g., `v0.2.2`)
2. `installer/coppercli.iss` - `MyAppVersion` define (without `v` prefix, e.g., `0.2.2`)

### Release Notes

Track new features, bug fixes, and changes in `RELEASES.md`. Add entries under the upcoming version section as features are implemented.
