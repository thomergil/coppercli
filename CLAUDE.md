# Claude Code Guidelines for coppercli

This project is derived from OpenCNCPilot (`~/src/OpenCNCPilot/`). When confused about GRBL communication or probing logic, check that reference implementation. **Note:** OpenCNCPilot does not support tool changes (M6), so coppercli's tool change logic has no reference implementation to compare against.

**Controller FSM documentation:** See `docs/CONTROLLER_LAYER_PROPOSAL.md` for state machine diagrams. For probe data lifecycle (autosave, recovery, save states), see the detailed documentation at the top of `coppercli.Core/Controllers/ProbeController.cs`.

G-code is typically generated by pcb2gcode. Custom tools are in `~/src/pcb2gcode-tools/`.

**When exploring other projects:** Always look for `README.md` or `README` files first to understand the project structure and available tools.

## Start of Conversation

Check for Dropbox conflicted copies and delete them:
```bash
find . -name "*conflicted*" -ls          # review first
find . -name "*conflicted*" -delete      # then delete
```

## Code Style

**OBSESSIVE DRYness.** Never duplicate code. If you write similar code twice, extract it immediately. Search for existing helpers before writing new code. Three similar lines are worse than one abstraction. This applies to: logic, constants, patterns, error handling, and validation.

**Assume it exists.** Before adding any constant, utility function, or helper, search extensively - it almost certainly already exists. Check `Constants.cs`, `CliConstants.cs`, `GrblProtocol.cs`, `WebConstants.cs`, `constants.js`, and the `Helpers/` directory. When in doubt, grep first.

**Before writing ANY logic, search first.** If you're about to write:
- A loop that waits/polls/retries → grep for existing wait functions in `MachineWait.cs`
- Status/state checking → check `MachineWait.cs`, `StatusHelpers.cs`
- Any pattern that "feels like it should exist" → it probably does, search for it

**When you catch yourself writing 5+ lines of logic**, stop and search. The codebase likely has a helper. If not, create one - don't inline it.

**Extend, don't duplicate.** If an existing function almost does what you need, add a parameter (like an `onPoll` callback) rather than copying and modifying the logic.

**Ultra-clean APIs.** Interfaces should be minimal and focused. Dependencies flow one direction. Controllers own workflows, UIs own presentation. Use records for immutable DTOs. Events are synchronous. No god objects.

**Refactor proactively.** When you encounter code that violates these principles, fix it - don't work around it. Technical debt compounds. Clean code now saves time later.

**Keep it simple.** If code gets complex (multiple flags, nested conditions, complex state tracking), stop and rethink. Keep files small. The answer to "want me to simplify this?" is always yes.

**Follow established patterns.** Study existing code before adding new code. Match naming conventions, file organization, and architectural patterns. Consistency matters more than personal preference.

**Always use braces** for control statements, even single-line bodies:
```csharp
if (condition)
{
    DoSomething();
}
```

**No magic values.** Every literal with semantic meaning must be a constant. This includes: timeouts, speeds/feeds, baud rates, status strings (`"Idle"`, `"Alarm"`), UI text, buffer sizes, retry counts, protocol values. If a constant doesn't exist, create it. Exception: logging strings (`Logger.Log(...)`) can use inline strings since they're for debugging, not user-facing.

```csharp
// BAD
Thread.Sleep(500);
if (status == "Home") ...
if (status.StartsWith("Alarm")) ...

// GOOD
Thread.Sleep(ConnectionDelayMs);
if (status == StatusHome) ...
if (status.StartsWith(StatusAlarm)) ...
```

**DRY.** Before writing new code, check `coppercli/Helpers/` for existing status checks, wait functions, machine commands, display utilities, and menu helpers. Extract repeated patterns into helpers:

```csharp
// Extract repeated checks into helpers
if (!RequireConnection()) return;
```

**Menu definitions** should be structured data, not scattered strings:
```csharp
static readonly (string Label, char Mnemonic, Action Handler)[] MainMenuItems = {
    ("Connect/Disconnect", 'c', ConnectionMenu),
    ("Home ($H)", 'h', HomeMenu),
};
```

### UI Patterns - NEVER Reinvent

Before writing ANY user-facing UI code, search for existing patterns:

**Menus:** Always use `MenuDef<T>` + `MenuItem<T>` + `MenuHelpers.ShowMenu()`. Never write raw `AnsiConsole.MarkupLine` menu items.

**Prompts:** Use `MenuHelpers.AskString()`, `MenuHelpers.AskNumber()`, `MenuHelpers.Confirm()`. Never use raw `Console.ReadLine()`.

**Errors:** Use `MenuHelpers.ShowError()`. Never write custom error display.

**Before implementing UI, grep for:**
- `MenuDef<` - how menus are built
- `ShowMenu` - how menus are displayed
- `AskString` - how text input works
- Similar features in other menus (ProbeMenu, FileMenu, etc.)

If you're about to write more than 3 lines of console output/input code, STOP and search for the existing utility.

### Finding Code Duplication

Use these tools to detect duplicated code:

```bash
# jscpd - Node-based, quick to run
npx jscpd --pattern "**/*.cs" --ignore "**/obj/**,**/bin/**" --min-tokens 50 --reporters console

# PMD CPD - More detailed output
pmd cpd --language cs --minimum-tokens 50 --dir .
```

The `--min-tokens` parameter controls sensitivity (50 ≈ 10-15 lines). Lower values catch more but produce noise.

### Periodic Code Quality Sweeps

Periodically audit the codebase for violations:

1. **Business logic in wrong place**: All workflows belong in Controllers (`coppercli.Core/Controllers/`), never in `CncWebServer.cs` or TUI menus. WebServer and menus should only handle presentation and delegate to controllers.

2. **Magic values**: Search for hardcoded strings and numbers that should be constants:
   ```bash
   # Find numeric literals in C# (excluding 0, 1, common patterns)
   grep -rn '\b[2-9][0-9]*\b' --include="*.cs" coppercli/ coppercli.Core/ | \
     grep -v 'Logger\|//\|\.csproj\|bin/\|obj/' | \
     awk -F: '{if ($3 !~ /const|enum|case|\.Length|\.Count|Version/) print}'

   # Find string literals in C# that might be constants
   grep -rn '"[A-Za-z][^"]*"' --include="*.cs" coppercli/ coppercli.Core/ | \
     grep -v 'Logger\|nameof\|//\|\.csproj\|bin/\|obj/' | head -50

   # Find numeric literals in JavaScript
   grep -rn '\b[2-9][0-9]*\b' --include="*.js" coppercli/WebServer/wwwroot/js/ | \
     grep -v 'console\.\|//\|\.min\.js'

   # Find string literals in JavaScript that might need constants
   grep -rn "'[A-Za-z][^']*'" --include="*.js" coppercli/WebServer/wwwroot/js/ | \
     grep -v 'console\.\|//\|import\|from' | head -50
   ```
   Every number > 1 and every string with semantic meaning should be a named constant.

3. **Code duplication**: Run duplication detection:
   ```bash
   npx jscpd --pattern "**/*.cs" --ignore "**/obj/**,**/bin/**" --min-tokens 50 --reporters console
   ```

4. **Constants shared via API**: When both server and client need the same value, expose it via `/api/constants` (see `GetSharedConstants()` in `CncWebServer.cs`). Never duplicate constants between C# and JavaScript.
   ```bash
   # Find hardcoded values in JS that might need to come from API
   grep -rn 'const.*=' --include="*.js" coppercli/WebServer/wwwroot/js/ | grep -v "import\|from\|=>"
   ```
   Check if any JS constants duplicate values from `CliConstants.cs`, `Constants.cs`, or `GrblProtocol.cs`. If so, add them to `GetSharedConstants()` and fetch from API.

5. **API endpoints use constants**: All API paths must be defined in constants files, not hardcoded in fetch calls.
   - C# server: `WebConstants.cs` defines `Api*` constants
   - JavaScript client: `constants.js` defines `API_*` constants
   ```bash
   # Find hardcoded API paths in JS (should use constants)
   grep -rn "fetch.*'/api" --include="*.js" coppercli/WebServer/wwwroot/js/
   ```

6. **WebSocket message types require 4-point updates**: When adding a new WebSocket message type (e.g., `probe:error`), update all four locations:
   - `WebConstants.cs`: Add `WsMessageType*` constant
   - `constants.js`: Add `MSG_TYPE_*` constant
   - `CncWebServer.cs`: Add to `wsMessageTypes` object in `GetSharedConstants()`
   - `helpers.js`: Import and add validation check in `validateConstants()`

   The validation in `helpers.js` catches mismatches at runtime. Verify all message types are validated:
   ```bash
   # List MSG_TYPE_* constants defined in constants.js
   grep -o 'MSG_TYPE_[A-Z_]*' coppercli/WebServer/wwwroot/js/constants.js | sort -u
   # List MSG_TYPE_* constants validated in helpers.js
   grep -o 'MSG_TYPE_[A-Z_]*' coppercli/WebServer/wwwroot/js/helpers.js | sort -u
   # These should match (use diff to compare)
   ```

## Project Structure

- `coppercli/` - Main application (.NET 8)
- `coppercli.Core/` - Platform-independent core library (.NET 8)

**Important:** Core cannot reference coppercli (dependency flows one way). Shared constants used by Core go in `coppercli.Core/Util/Constants.cs`.

### Constants Location

- **`coppercli.Core/Util/Constants.cs`** - Shared constants used by Core (serial timeouts, buffer sizes, GRBL defaults)
- **`coppercli/CliConstants.cs`** - CLI-specific constants (UI text, display settings, menu timing)
- **`coppercli.Core/Util/GrblProtocol.cs`** - GRBL protocol constants (status strings, commands)

### Helper Organization

- **`coppercli.Core/Controllers/MachineWait.cs`** - Status checks (`IsIdle`, `IsAlarm`, `IsHold`, `IsDoor`, `IsProblematic`), async wait functions, `HomeAsync` (single source of truth for homing)
- **`MachineCommands.cs`** - Sync wrappers for MachineWait, G-code patterns (`MoveToSafeHeight`, `HomeAndWait`, `EnsureMachineReady`)
- **`MenuHelpers.cs`** - Menus, prompts, confirmations, validation (`GetProbeDisabledReason`, `ValidateMillPreflight`)
- **`DisplayHelpers.cs`** - ANSI codes (`AnsiError`, `AnsiSuccess`, etc.), `WriteLineTruncated`, overlay box helpers
- **`InputHelpers.cs`** - Key checking (`IsKey`, `IsEnterKey`, `IsEscapeKey`, `IsExitKey`), `ReadKeyPolling`

### Mandatory Helper Usage

**ALWAYS use these helpers instead of raw code:**

```csharp
// BAD - raw key checking
if (key.Key == ConsoleKey.Escape) ...
if (key.Key == ConsoleKey.Enter) ...
if (char.ToLower(key.KeyChar) == 'y') ...

// GOOD - use InputHelpers
if (InputHelpers.IsEscapeKey(key)) ...
if (InputHelpers.IsEnterKey(key)) ...
if (InputHelpers.IsKey(key, ConsoleKey.Y)) ...

// BAD - raw console size
int width = Console.WindowWidth;

// GOOD - safe wrapper
var (width, height) = DisplayHelpers.GetSafeWindowSize();

// BAD - raw status checks
if (machine.Status == "Idle") ...
if (machine.Status.StartsWith("Alarm")) ...

// GOOD - use MachineWait helpers
if (MachineWait.IsIdle(machine)) ...
if (MachineWait.IsAlarm(machine)) ...

// BAD - manual confirmation
AnsiConsole.Confirm("Continue?");

// GOOD - use MenuHelpers (supports quit option)
MenuHelpers.Confirm("Continue?");
MenuHelpers.ConfirmOrQuit("Continue?");
```

### Overlay Box Pattern

For alerts/errors in full-screen TUI modes, use the overlay helpers in `DisplayHelpers.cs`:

- **`ShowOverlayAndWait(message, subtext, color)`** - Draws centered overlay box and waits for Enter. Use for errors/alerts.
- **`ShowOverlayTimed(message, durationMs, subtext, color)`** - Draws overlay for specified duration then returns. Use for confirmations.

Both functions handle newlines in message/subtext automatically - the box height adjusts to fit content (6 fixed lines + N content lines). Structure: margin, border, padding, [content], padding, border, margin.

For continuous redraws (MillMenu/MacroRunner), use the lower-level helpers:
- **`GetOverlayBoxLine(lineIndex, boxWidth, contentLines[], colors[])`** - Dynamic height, array-based.
- **`GetOverlayBoxLine(lineIndex, boxWidth, line1, color1, line2, color2)`** - Legacy 2-line version.
- **`CalculateOverlayBoxHeight(contentLines[])`** - Returns `OverlayBoxFixedLines + contentLines.Length`.
- **`CalculateOverlayBoxWidth(contentLines[], maxWidth)`** - Respects min/max constraints.
- **`CompositeOverlay(background, overlay, start, width)`** - Composites overlay onto background.

### Machine State: Single Source of Truth

Machine state properties (e.g., `IsHomed`) belong in the `Machine` class, not in `AppState`. This ensures:
- One place sets the state (in Core)
- All code paths (CLI, Web UI, controllers) use the same state
- Controllers in Core can access the state directly

**Pattern: Homing as example**

The `Machine.IsHomed` property is set in exactly ONE place:

```csharp
// coppercli.Core/Controllers/MachineWait.cs
public static async Task<bool> HomeAsync(IMachine machine, int timeoutMs, CancellationToken ct)
{
    machine.SendLine(CmdHome);
    bool success = await WaitForIdleAsync(machine, timeoutMs, ct);
    if (!success || !IsIdle(machine))
    {
        return false;
    }
    machine.IsHomed = true;  // SINGLE place where IsHomed is set
    return true;
}
```

All callers use this method:
- **Sync CLI callers** use `MachineCommands.HomeAndWait()` which wraps `MachineWait.HomeAsync()`
- **Async controllers** call `MachineWait.HomeAsync()` directly
- **Readers** access `machine.IsHomed` (not `AppState.IsHomed`)

```csharp
// BAD - scattered state updates
// ConnectionMenu.cs
AppState.IsHomed = true;
// WebServer.cs
AppState.IsHomed = true;
// MillMenu.cs
AppState.IsHomed = true;

// GOOD - single source of truth
// All callers use MachineWait.HomeAsync() or MachineCommands.HomeAndWait()
// Readers access machine.IsHomed
RequireHoming = !machine.IsHomed;
```

## Debugging

Log file location: `coppercli/bin/Debug/net8.0/coppercli.log`

**When debugging a problem:** Aggressively add logging using `Logger.Log()`. The user will run with `--debug` to enable logging. Do NOT remove debug logging until the user explicitly says the problem is fixed. Console output is often overwritten by UI redraws, so always use the log file.

**NEVER suggest the user forgot to compile.** If something isn't working as expected, assume the code is wrong and investigate further.

## Git

**IMPORTANT:** NEVER run git commands (add, commit, push, etc.) unless the user EXPLICITLY asks. Do not volunteer git commands. Do not stage files automatically after editing. Do not commit. Do not push. Wait for explicit instructions.

## Building

**IMPORTANT:** Do not compile unless the user explicitly asks. This project is synced via Dropbox, and compiling while the user is also working can create conflicted copies of build artifacts.

### dotnet on macOS

On macOS, `dotnet` is often not in PATH. Use this absolute path:
```
/opt/homebrew/Cellar/dotnet@8/8.0.123/bin/dotnet
```

### Running

Use the platform-agnostic run scripts which auto-detect dotnet location:

```bash
# macOS/Linux
./run.sh

# Windows (double-click or command line)
run.bat
```

### Manual build commands

```bash
dotnet build coppercli/coppercli.csproj
dotnet run --project coppercli/coppercli.csproj
dotnet build coppercli/coppercli.csproj -warnaserror  # treat warnings as errors
```

## Releases

### Creating a Release

Releases are automated via GitHub Actions. When you push a tag, GitHub builds for all platforms and creates a release:

```bash
git tag v0.1.2
git push origin v0.1.2
```

This automatically:
- Builds Windows x64 (portable exe)
- Builds Windows installer (via Inno Setup)
- Builds macOS ARM64 and x64
- Builds Linux x64
- Creates a GitHub Release with all artifacts

### Windows Installer

The Windows installer is built with [Inno Setup](https://jrsoftware.org/isinfo.php). Configuration is in `installer/coppercli.iss`.

To build locally on Windows:
```bash
installer\build-installer.bat
```

The icon (`installer/coppercli.ico`) was generated from a JPG using ImageMagick:
```bash
magick input.jpg -define icon:auto-resize=256,128,64,48,32,16 coppercli.ico
```

### Homebrew Tap

The Homebrew tap is a separate repo: `github.com/thomergil/homebrew-coppercli` (cloned at `~/src/homebrew-coppercli`).

After creating a GitHub release, update the formula. For example:
```bash
./scripts/update-homebrew-formula.sh v0.1.2
cd ~/src/homebrew-coppercli
git add Formula/coppercli.rb
git commit -m "Update to v0.1.2"
git push
```

### Version Number

The version must be updated in **two places** before creating a release:

1. `coppercli/CliConstants.cs` - `AppVersion` constant (with `v` prefix, e.g., `v0.2.2`)
2. `installer/coppercli.iss` - `MyAppVersion` define (without `v` prefix, e.g., `0.2.2`)

### Release Notes

Track new features, bug fixes, and changes in `RELEASES.md`. Add entries under the upcoming version section as features are implemented.
